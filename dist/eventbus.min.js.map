{"version":3,"file":"eventbus.min.js","sources":["../src/model/NamedEvent.js","../src/model/EventListener.js","../src/eventbus.js"],"sourcesContent":["export class NamedEvent {\n\n    constructor(name) {\n        this._name = name;\n    }\n\n    getName() {\n        return this._name;\n    }\n}\n","export class EventListener {\n    constructor(event, callback, ...callbackArguments)\n    {\n        this.event = event;\n        this.callback = callback;\n        this.callbackArguments = [...callbackArguments];\n    }\n}\n","import {NamedEvent} from \"./model/NamedEvent\";\nimport {EventListener} from \"./model/EventListener\";\n\nexport class EventBus {\n\n    constructor() {\n        this.events = {};\n    }\n\n    static create() {\n        return eventBus;\n    }\n\n    /**\n     * @param {string|NamedEvent} event\n     * @return NamedEvent\n     */\n    _toEvent(event) {\n        if (typeof event === 'string') {\n            return  new NamedEvent(event);\n        }\n        if (typeof event === \"function\") {\n            event.getName = () => event.name\n        }\n\n        return event;\n    }\n\n    /**\n     * Adds listener to EventBus\n     * @param {string|NamedEvent|function} event The name or NameEvent instance of the event to listen for\n     * @param {function} callback Callback to call when event was triggered\n     * @param  {...*} args Any number of args to be passed to the callback\n     */\n    addEventListener(event, callback, ...args) {\n        event = this._toEvent(event);\n        const eventName = event.getName();\n\n        if (typeof this.events[eventName] === \"undefined\") { // Check if there is already event of this eventName registered\n            this.events[eventName] = []; // If not, create array for it\n        }\n        const eventListener = new EventListener(event, callback, ...args);\n        this.events[eventName].push(eventListener); // Finally push new event to events array\n    }\n\n    /**\n     * Removes listener from EventBus\n     * @param {string|NamedEvent} event The name of the event to remove\n     * @param {function} callback Callback of the event to remove\n     */\n    removeEventListener(event, callback) {\n        event = this._toEvent(event);\n        const eventName = event.getName();\n\n        if (typeof this.events[eventName] === \"undefined\") { // Check if event of this type exists\n            return; // If not just return\n        }\n\n        // keep all elements that aren't equal to the passed event\n        const filterFn = listener => listener.event.getName() !== event.getName() || listener.callback !== callback;\n        this.events[eventName] = this.events[eventName].filter(filterFn);\n    }\n\n    /**\n     * Checks if the passed event is registered in the EventBus\n     * @param {string|NamedEvent} event Type of the to be checked event\n     * @param {callback} callback Callback of the to be checked event\\\n     */\n    has(event, callback) {\n        event = this._toEvent(event);\n        const eventName = event.getName();\n        if (typeof this.events[eventName] === \"undefined\") { // Check if the passed eventName even exists\n            return false; // If not, quit method\n        }\n\n        // If callback and scope are undefined then every registered event is match, thus any event of the eventName matches\n        let numOfCallbacks = this.events[eventName].length;\n        if (callback === undefined) { // If callback are not defined\n            return numOfCallbacks > 0; // If there are any callbacks we can be sure it matches the passed one\n        }\n\n        const conditionFn = listener => {\n            const callbackIsSame = listener.callback === callback; // Check if callback is equal to the one passed\n            if (callbackIsSame) { // Check if current listener and passed listener are equal\n                return true; // If so, break loop and return true\n            }\n        };\n        return this.events[eventName].some(conditionFn);\n    }\n\n    /**\n     * Dispatch is a function to emits an event addEventListener the EventBus\n     * @param {string|NamedEvent} event Type of event to dispatch\n     * @param {...any} args Any number of args to be passed to the callback\n     */\n    dispatch(event, ...args) {\n        event = this._toEvent(event);\n        const eventName = event.getName();\n\n        if (typeof this.events[eventName] === \"undefined\") { // Check if any event of the passed eventName exists\n            return; // If not, quit method\n        }\n\n        const listeners = this.events[eventName].slice(); // Little hack to clone array\n\n        for (const listener of listeners) { // Iterate all events\n            if (listener && listener.callback) { // Check if callback of event is set\n                listener.scope = listener.callback.apply(listener.callback, [event, ...args, ...listener.callbackArguments]);\n            }\n        }\n    }\n\n    debug() {\n        let str = \"\";\n        for (const [name, listeners] of Object.entries(this.events)) {\n            for (const listener of listeners) {\n                let className = listener.scope || \"Anonymous\";\n                str += `${className} listening for \"${name}\"\\n`;\n            }\n        }\n        return str;\n    }\n\n}\n\nconst eventBus = new EventBus();\nexport default EventBus;\nexport {NamedEvent};\n"],"names":["NamedEvent","[object Object]","name","this","_name","EventListener","event","callback","callbackArguments","EventBus","events","eventBus","getName","args","eventName","_toEvent","eventListener","push","filter","listener","numOfCallbacks","length","undefined","some","listeners","slice","scope","apply","str","Object","entries"],"mappings":"AAAO,MAAMA,EAETC,YAAYC,GACRC,KAAKC,MAAQF,EAGjBD,UACI,OAAOE,KAAKC,OCPb,MAAMC,EACTJ,YAAYK,EAAOC,KAAaC,GAE5BL,KAAKG,MAAQA,EACbH,KAAKI,SAAWA,EAChBJ,KAAKK,kBAAoB,IAAIA,ICF9B,MAAMC,EAETR,cACIE,KAAKO,OAAS,GAGlBT,gBACI,OAAOU,EAOXV,SAASK,GACL,MAAqB,iBAAVA,EACC,IAAIN,EAAWM,IAEN,mBAAVA,IACPA,EAAMM,QAAU,IAAMN,EAAMJ,MAGzBI,GASXL,iBAAiBK,EAAOC,KAAaM,GAEjC,MAAMC,GADNR,EAAQH,KAAKY,SAAST,IACEM,eAEc,IAA3BT,KAAKO,OAAOI,KACnBX,KAAKO,OAAOI,GAAa,IAE7B,MAAME,EAAgB,IAAIX,EAAcC,EAAOC,KAAaM,GAC5DV,KAAKO,OAAOI,GAAWG,KAAKD,GAQhCf,oBAAoBK,EAAOC,GAEvB,MAAMO,GADNR,EAAQH,KAAKY,SAAST,IACEM,UAExB,QAAsC,IAA3BT,KAAKO,OAAOI,GACnB,OAKJX,KAAKO,OAAOI,GAAaX,KAAKO,OAAOI,GAAWI,QAD/BC,GAAYA,EAASb,MAAMM,YAAcN,EAAMM,WAAaO,EAASZ,WAAaA,IASvGN,IAAIK,EAAOC,GAEP,MAAMO,GADNR,EAAQH,KAAKY,SAAST,IACEM,UACxB,QAAsC,IAA3BT,KAAKO,OAAOI,GACnB,OAAO,EAIX,IAAIM,EAAiBjB,KAAKO,OAAOI,GAAWO,OAC5C,QAAiBC,IAAbf,EACA,OAAOa,EAAiB,EAS5B,OAAOjB,KAAKO,OAAOI,GAAWS,MANVJ,IAEhB,GADuBA,EAASZ,WAAaA,EAEzC,OAAO,KAWnBN,SAASK,KAAUO,GAEf,MAAMC,GADNR,EAAQH,KAAKY,SAAST,IACEM,UAExB,QAAsC,IAA3BT,KAAKO,OAAOI,GACnB,OAGJ,MAAMU,EAAYrB,KAAKO,OAAOI,GAAWW,QAEzC,IAAK,MAAMN,KAAYK,EACfL,GAAYA,EAASZ,WACrBY,EAASO,MAAQP,EAASZ,SAASoB,MAAMR,EAASZ,SAAU,CAACD,KAAUO,KAASM,EAASX,qBAKrGP,QACI,IAAI2B,EAAM,GACV,IAAK,MAAO1B,EAAMsB,KAAcK,OAAOC,QAAQ3B,KAAKO,QAChD,IAAK,MAAMS,KAAYK,EAAW,CAE9BI,GAAO,GADST,EAASO,OAAS,8BACIxB,OAG9C,OAAO0B,GAKf,MAAMjB,EAAW,IAAIF"}