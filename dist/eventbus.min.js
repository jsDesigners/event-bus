class t{constructor(t){this._name=t}getName(){return this._name}}class e{constructor(t,e,...s){this.event=t,this.callback=e,this.callbackArguments=[...s]}}class s{constructor(){this.events={}}static create(){return n}_toEvent(e){return"string"==typeof e?new t(e):("function"==typeof e&&(e.getName=()=>e.constructor.name),e)}addEventListener(t,s,...n){const o=(t=this._toEvent(t)).getName();void 0===this.events[o]&&(this.events[o]=[]);const c=new e(t,s,...n);this.events[o].push(c)}removeEventListener(t,e){const s=(t=this._toEvent(t)).getName();if(void 0===this.events[s])return;this.events[s]=this.events[s].filter((s=>s.event.getName()!==t.getName()||s.callback!==e))}has(t,e){const s=(t=this._toEvent(t)).getName();if(void 0===this.events[s])return!1;let n=this.events[s].length;if(void 0===e)return n>0;return this.events[s].some((t=>{if(t.callback===e)return!0}))}dispatch(t,...e){const s=(t=this._toEvent(t)).getName();if(void 0===this.events[s])return;const n=this.events[s].slice();for(const s of n)s&&s.callback&&(s.scope=s.callback.apply(s.callback,[t,...e,...s.callbackArguments]))}debug(){let t="";for(const[e,s]of Object.entries(this.events))for(const n of s){t+=`${n.scope||"Anonymous"} listening for "${e}"\n`}return t}}const n=new s;export default s;export{s as EventBus,t as NamedEvent};
//# sourceMappingURL=eventbus.min.js.map
