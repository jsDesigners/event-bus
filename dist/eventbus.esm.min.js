class e{constructor(){this.events={}}static create(){return t}addEventListener(e,t,...s){void 0===this.events[e]&&(this.events[e]=[]),this.events[e].push({callback:t,args:s})}removeEventListener(e,t){if(void 0===this.events[e])return;this.events[e]=this.events[e].filter(e=>e.callback!==t)}has(e,t){if(void 0===this.events[e])return!1;let s=this.events[e].length;if(void 0===t)return s>0;return this.events[e].some(e=>{if(e.callback===t)return!0})}dispatch(e,...t){if(void 0===this.events[e])return;const s=this.events[e].slice();for(const e of s)e&&e.callback&&(e.scope=e.callback.apply())}debug(){let e="";for(const[t,s]of Object.entries(this.events))for(const n of s){e+=`${n.scope||"Anonymous"} listening for "${t}"\n`}return e}}const t=new e;export default e;export{e as EventBus};
//# sourceMappingURL=eventbus.esm.min.js.map
