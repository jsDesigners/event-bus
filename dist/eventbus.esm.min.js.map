{"version":3,"file":"eventbus.esm.min.js","sources":["../src/eventbus.js"],"sourcesContent":["export class EventBus {\n\n    constructor() {\n        this.events = {};\n    }\n\n    static create() {\n        return eventBus;\n    }\n\n    /**\n     * Adds listener to EventBus\n     * @param {string} eventName The name of the event to listen for\n     * @param {function} callback Callback to call when event was triggered\n     * @param {object} scope The scope in which the callback shall be executed\n     * @param  {...any} args Any number of args to be passed to the callback\n     */\n    addEventListener(eventName, callback, scope, ...args) {\n        if (typeof this.events[eventName] === \"undefined\") { // Check if there is already event of this eventName registered\n            this.events[eventName] = []; // If not, create array for it\n        }\n        this.events[eventName].push({scope, callback, args}); // Finally push new event to events array\n    }\n\n    /**\n     * Removes listener from EventBus\n     * @param {string} eventName The name of the event to remove\n     * @param {function} callback Callback of the event to remove\n     * @param {object} scope The scope of the to be removed event\n     */\n    removeEventListener(eventName, callback, scope) {\n        if (typeof this.events[eventName] === \"undefined\") { // Check if event of this type exists\n            return; // If not just return\n        }\n\n        // keep all elements that aren't equal to the passed event\n        const filterFn = event => event.scope !== scope || event.callback !== callback;\n        this.events[eventName] = this.events[eventName].filter(filterFn);\n    }\n\n    /**\n     * Checks if the passed event is registered in the EventBus\n     * @param {string} eventName Type of the to be checked event\n     * @param {callback} callback Callback of the to be checked event\n     * @param {object} scope Scope of the to be checked event\n     */\n    has(eventName, callback, scope) {\n        if (typeof this.events[eventName] === \"undefined\") { // Check if the passed eventName even exists\n            return false; // If not, quit method\n        }\n\n        // If callback and scope are undefined then every registered event is match, thus any event of the eventName matches\n        let numOfCallbacks = this.events[eventName].length;\n        if (callback === undefined && scope === undefined) { // If scope and callback are not defined\n            return numOfCallbacks > 0; // If there are any callbacks we can be sure it matches the passed one\n        }\n\n        const conditionFn = event => {\n            const scopeIsSame = scope ? event.scope === scope : true; // Check if scope is equal to the one passed\n            const callbackIsSame = event.callback === callback; // Check if callback is equal to the one passed\n            if (scopeIsSame && callbackIsSame) { // Check if current event and passed event are equal\n                return true; // If so, break loop and return true\n            }\n        };\n        return this.events[eventName].some(conditionFn);\n    }\n\n    /**\n     * Dispatch is a function to emits an event addEventListener the EventBus\n     * @param {string} eventName Type of event to dispatch\n     * @param {object} caller The caller\n     * @param {...any} args Any number of args to be passed to the callback\n     */\n    dispatch(eventName, caller, ...args) {\n        if (typeof this.events[eventName] === \"undefined\") { // Check if any event of the passed eventName exists\n            return; // If not, quit method\n        }\n\n        let bag = {type: eventName, target: caller};\n\n        const events = this.events[eventName].slice(); // Little hack to clone array\n\n        for (const event of events) { // Iterate all events\n            if (event && event.callback) { // Check if callback of event is set\n                event.callback.apply(event.scope, [bag, ...args, ...event.args]); // Call callback\n            }\n        }\n    }\n\n    debug() {\n        let str = \"\";\n        for (const [type, events] of Object.entries(this.events)) {\n            for (const event of events) {\n                let className = event.scope && event.scope.constructor.name || \"Anonymous\";\n                str += `${className} listening for \"${type}\"\\n`;\n            }\n        }\n        return str;\n    }\n\n}\nconst eventBus = new EventBus();\nexport default EventBus;\n"],"names":["EventBus","[object Object]","this","events","eventBus","eventName","callback","scope","args","push","filter","event","numOfCallbacks","length","undefined","some","scopeIsSame","callbackIsSame","caller","bag","type","target","slice","apply","str","Object","entries","constructor","name"],"mappings":"AAAO,MAAMA,EAETC,cACIC,KAAKC,OAAS,GAGlBF,gBACI,OAAOG,EAUXH,iBAAiBI,EAAWC,EAAUC,KAAUC,QACN,IAA3BN,KAAKC,OAAOE,KACnBH,KAAKC,OAAOE,GAAa,IAE7BH,KAAKC,OAAOE,GAAWI,KAAK,CAACF,MAAAA,EAAOD,SAAAA,EAAUE,KAAAA,IASlDP,oBAAoBI,EAAWC,EAAUC,GACrC,QAAsC,IAA3BL,KAAKC,OAAOE,GACnB,OAKJH,KAAKC,OAAOE,GAAaH,KAAKC,OAAOE,GAAWK,OAD/BC,GAASA,EAAMJ,QAAUA,GAASI,EAAML,WAAaA,GAU1EL,IAAII,EAAWC,EAAUC,GACrB,QAAsC,IAA3BL,KAAKC,OAAOE,GACnB,OAAO,EAIX,IAAIO,EAAiBV,KAAKC,OAAOE,GAAWQ,OAC5C,QAAiBC,IAAbR,QAAoCQ,IAAVP,EAC1B,OAAOK,EAAiB,EAU5B,OAAOV,KAAKC,OAAOE,GAAWU,KAPVJ,IAChB,MAAMK,GAAcT,GAAQI,EAAMJ,QAAUA,EACtCU,EAAiBN,EAAML,WAAaA,EAC1C,GAAIU,GAAeC,EACf,OAAO,IAYnBhB,SAASI,EAAWa,KAAWV,GAC3B,QAAsC,IAA3BN,KAAKC,OAAOE,GACnB,OAGJ,IAAIc,EAAM,CAACC,KAAMf,EAAWgB,OAAQH,GAEpC,MAAMf,EAASD,KAAKC,OAAOE,GAAWiB,QAEtC,IAAK,MAAMX,KAASR,EACZQ,GAASA,EAAML,UACfK,EAAML,SAASiB,MAAMZ,EAAMJ,MAAO,CAACY,KAAQX,KAASG,EAAMH,OAKtEP,QACI,IAAIuB,EAAM,GACV,IAAK,MAAOJ,EAAMjB,KAAWsB,OAAOC,QAAQxB,KAAKC,QAC7C,IAAK,MAAMQ,KAASR,EAAQ,CAExBqB,MADgBb,EAAMJ,OAASI,EAAMJ,MAAMoB,YAAYC,MAAQ,8BACzBR,OAG9C,OAAOI,GAIf,MAAMpB,EAAW,IAAIJ"}