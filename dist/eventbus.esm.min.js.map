{"version":3,"file":"eventbus.esm.min.js","sources":["../src/eventbus.js"],"sourcesContent":["export class EventBus {\n\n    constructor() {\n        this.events = {};\n    }\n\n    static create() {\n        return eventBus;\n    }\n\n    /**\n     * Adds listener to EventBus\n     * @param {string} eventName The name of the event to listen for\n     * @param {function} callback Callback to call when event was triggered\n     * @param  {...any} args Any number of args to be passed to the callback\n     */\n    addEventListener(eventName, callback, ...args) {\n        if (typeof this.events[eventName] === \"undefined\") { // Check if there is already event of this eventName registered\n            this.events[eventName] = []; // If not, create array for it\n        }\n        this.events[eventName].push({callback, args}); // Finally push new event to events array\n    }\n\n    /**\n     * Removes listener from EventBus\n     * @param {string} eventName The name of the event to remove\n     * @param {function} callback Callback of the event to remove\n     */\n    removeEventListener(eventName, callback) {\n        if (typeof this.events[eventName] === \"undefined\") { // Check if event of this type exists\n            return; // If not just return\n        }\n\n        // keep all elements that aren't equal to the passed event\n        const filterFn = event => event.callback !== callback;\n        this.events[eventName] = this.events[eventName].filter(filterFn);\n    }\n\n    /**\n     * Checks if the passed event is registered in the EventBus\n     * @param {string} eventName Type of the to be checked event\n     * @param {callback} callback Callback of the to be checked event\\\n     */\n    has(eventName, callback) {\n        if (typeof this.events[eventName] === \"undefined\") { // Check if the passed eventName even exists\n            return false; // If not, quit method\n        }\n\n        // If callback and scope are undefined then every registered event is match, thus any event of the eventName matches\n        let numOfCallbacks = this.events[eventName].length;\n        if (callback === undefined) { // If callback are not defined\n            return numOfCallbacks > 0; // If there are any callbacks we can be sure it matches the passed one\n        }\n\n        const conditionFn = event => {\n            const callbackIsSame = event.callback === callback; // Check if callback is equal to the one passed\n            if (callbackIsSame) { // Check if current event and passed event are equal\n                return true; // If so, break loop and return true\n            }\n        };\n        return this.events[eventName].some(conditionFn);\n    }\n\n    /**\n     * Dispatch is a function to emits an event addEventListener the EventBus\n     * @param {string} eventName Type of event to dispatch\n     * @param {...any} args Any number of args to be passed to the callback\n     */\n    dispatch(eventName, ...args) {\n        if (typeof this.events[eventName] === \"undefined\") { // Check if any event of the passed eventName exists\n            return; // If not, quit method\n        }\n\n        const events = this.events[eventName].slice(); // Little hack to clone array\n\n        for (const event of events) { // Iterate all events\n            if (event && event.callback) { // Check if callback of event is set\n                event.scope = event.callback.apply();// Call callback\n            }\n        }\n    }\n\n    debug() {\n        let str = \"\";\n        for (const [type, events] of Object.entries(this.events)) {\n            for (const event of events) {\n                let className = event.scope || \"Anonymous\";\n                str += `${className} listening for \"${type}\"\\n`;\n            }\n        }\n        return str;\n    }\n\n}\nconst eventBus = new EventBus();\nexport default EventBus;\n"],"names":["EventBus","[object Object]","this","events","eventBus","eventName","callback","args","push","filter","event","numOfCallbacks","length","undefined","some","slice","scope","apply","str","type","Object","entries"],"mappings":"AAAO,MAAMA,EAETC,cACIC,KAAKC,OAAS,GAGlBF,gBACI,OAAOG,EASXH,iBAAiBI,EAAWC,KAAaC,QACC,IAA3BL,KAAKC,OAAOE,KACnBH,KAAKC,OAAOE,GAAa,IAE7BH,KAAKC,OAAOE,GAAWG,KAAK,CAACF,SAAAA,EAAUC,KAAAA,IAQ3CN,oBAAoBI,EAAWC,GAC3B,QAAsC,IAA3BJ,KAAKC,OAAOE,GACnB,OAKJH,KAAKC,OAAOE,GAAaH,KAAKC,OAAOE,GAAWI,OAD/BC,GAASA,EAAMJ,WAAaA,GASjDL,IAAII,EAAWC,GACX,QAAsC,IAA3BJ,KAAKC,OAAOE,GACnB,OAAO,EAIX,IAAIM,EAAiBT,KAAKC,OAAOE,GAAWO,OAC5C,QAAiBC,IAAbP,EACA,OAAOK,EAAiB,EAS5B,OAAOT,KAAKC,OAAOE,GAAWS,KANVJ,IAEhB,GADuBA,EAAMJ,WAAaA,EAEtC,OAAO,IAWnBL,SAASI,KAAcE,GACnB,QAAsC,IAA3BL,KAAKC,OAAOE,GACnB,OAGJ,MAAMF,EAASD,KAAKC,OAAOE,GAAWU,QAEtC,IAAK,MAAML,KAASP,EACZO,GAASA,EAAMJ,WACfI,EAAMM,MAAQN,EAAMJ,SAASW,SAKzChB,QACI,IAAIiB,EAAM,GACV,IAAK,MAAOC,EAAMhB,KAAWiB,OAAOC,QAAQnB,KAAKC,QAC7C,IAAK,MAAMO,KAASP,EAAQ,CAExBe,MADgBR,EAAMM,OAAS,8BACOG,OAG9C,OAAOD,GAIf,MAAMd,EAAW,IAAIJ"}